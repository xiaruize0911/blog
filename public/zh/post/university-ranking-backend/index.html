<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>使用 Vibe Coding 构建大学排名后端 | xiaruize's Blog</title><meta name=keywords content="Python,Flask,Backend,API,SQLite"><meta name=description content='在这篇文章中，我将分享构建 University Ranking Backend 的过程。这是一个 RESTful API，用于聚合和提供来自 QS 和 US News 等权威机构的大学排名数据。我们将探讨 Vibe Coding 策略、技术架构和驱动系统的核心算法。
📚 完整系列阅读
这个项目内容丰富，我将其分为深入系列文章：

第一部分：核心逻辑与 API 架构

探索 app.py 应用入口
解析 models/universities.py 中的"智能表选择"算法
讲解 API 路由的实现


第二部分：数据工程与脚本

介绍 ETL 流程（提取、转换、加载）
展示如何在不同数据集间标准化大学名称
阐述动态排名发现机制



🚀 项目介绍
University Ranking Backend 是一个集中式服务，为全球大学提供详细信息。
核心功能：

数据聚合：整合来自多个来源（QS、US News、Niche）的排名数据
多语言支持：内置英文和中文大学名称支持
智能过滤：支持按名称、国家、城市和排名标准进行搜索

目标是创建一个轻量级、易查询的接口，让前端应用能轻松使用，无需关心合并不同排名数据的复杂逻辑。
💡 Vibe Coding 策略
&ldquo;Vibe Coding&rdquo; 是一种 AI 辅助编码方法，开发者与 AI 工具协作加速开发，AI 充当协作伙伴处理重复任务、生成模板代码，并快速探索解决方案。本项目采用 数据驱动、逻辑其次 的策略，并得到 AI 的充分协助。

数据收集与质量检查：

首先在 data/ 目录收集原始数据（CSV、JSON 格式）
通过"质量检查"确保数据统一一致、排名准确、格式规范


脚本化处理流程：

编写独立脚本（scripts/ 目录）处理原始数据和填充 SQLite 数据库
这样做能将混乱的数据清洗与干净的应用逻辑分离


API 作为网关：

数据库就绪后，Flask API 作为简单网关构建
重点是让端点易用直观（/filter、/search），而非过度设计



查看 第一部分 和 第二部分 了解 &ldquo;Vibe Coding&rdquo;（AI 辅助开发）如何影响代码结构的具体例子，比如延迟导入和动态表发现。这些模式都通过 AI 协助优化，避免常见陷阱并提升可扩展性。'><meta name=author content><link rel=canonical href=https://xiaruize.org/zh/post/university-ranking-backend/><link crossorigin=anonymous href=/assets/css/stylesheet.e1f5c4cae44599655f7ff95195ff89c8cb3adbda94f2b1581a434ab2b4d4e6cf.css integrity="sha256-4fXEyuRFmWVff/lRlf+JyMs629qU8rFYGkNKsrTU5s8=" rel="preload stylesheet" as=style><link rel=icon href=https://xiaruize.org/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://xiaruize.org/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://xiaruize.org/favicon-32x32.png><link rel=apple-touch-icon href=https://xiaruize.org/apple-touch-icon.png><link rel=mask-icon href=https://xiaruize.org/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://xiaruize.org/post/university-ranking-backend/><link rel=alternate hreflang=zh href=https://xiaruize.org/zh/post/university-ranking-backend/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://xiaruize.org/zh/post/university-ranking-backend/"><meta property="og:site_name" content="xiaruize's Blog"><meta property="og:title" content="使用 Vibe Coding 构建大学排名后端"><meta property="og:description" content='在这篇文章中，我将分享构建 University Ranking Backend 的过程。这是一个 RESTful API，用于聚合和提供来自 QS 和 US News 等权威机构的大学排名数据。我们将探讨 Vibe Coding 策略、技术架构和驱动系统的核心算法。
📚 完整系列阅读 这个项目内容丰富，我将其分为深入系列文章：
第一部分：核心逻辑与 API 架构 探索 app.py 应用入口 解析 models/universities.py 中的"智能表选择"算法 讲解 API 路由的实现 第二部分：数据工程与脚本 介绍 ETL 流程（提取、转换、加载） 展示如何在不同数据集间标准化大学名称 阐述动态排名发现机制 🚀 项目介绍 University Ranking Backend 是一个集中式服务，为全球大学提供详细信息。
核心功能：
数据聚合：整合来自多个来源（QS、US News、Niche）的排名数据 多语言支持：内置英文和中文大学名称支持 智能过滤：支持按名称、国家、城市和排名标准进行搜索 目标是创建一个轻量级、易查询的接口，让前端应用能轻松使用，无需关心合并不同排名数据的复杂逻辑。
💡 Vibe Coding 策略 “Vibe Coding” 是一种 AI 辅助编码方法，开发者与 AI 工具协作加速开发，AI 充当协作伙伴处理重复任务、生成模板代码，并快速探索解决方案。本项目采用 数据驱动、逻辑其次 的策略，并得到 AI 的充分协助。
数据收集与质量检查： 首先在 data/ 目录收集原始数据（CSV、JSON 格式） 通过"质量检查"确保数据统一一致、排名准确、格式规范 脚本化处理流程： 编写独立脚本（scripts/ 目录）处理原始数据和填充 SQLite 数据库 这样做能将混乱的数据清洗与干净的应用逻辑分离 API 作为网关： 数据库就绪后，Flask API 作为简单网关构建 重点是让端点易用直观（/filter、/search），而非过度设计 查看 第一部分 和 第二部分 了解 “Vibe Coding”（AI 辅助开发）如何影响代码结构的具体例子，比如延迟导入和动态表发现。这些模式都通过 AI 协助优化，避免常见陷阱并提升可扩展性。'><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2025-12-07T00:00:00+00:00"><meta property="article:modified_time" content="2025-12-07T00:00:00+00:00"><meta property="article:tag" content="Python"><meta property="article:tag" content="Flask"><meta property="article:tag" content="Backend"><meta property="article:tag" content="API"><meta property="article:tag" content="SQLite"><meta name=twitter:card content="summary"><meta name=twitter:title content="使用 Vibe Coding 构建大学排名后端"><meta name=twitter:description content='在这篇文章中，我将分享构建 University Ranking Backend 的过程。这是一个 RESTful API，用于聚合和提供来自 QS 和 US News 等权威机构的大学排名数据。我们将探讨 Vibe Coding 策略、技术架构和驱动系统的核心算法。
📚 完整系列阅读
这个项目内容丰富，我将其分为深入系列文章：

第一部分：核心逻辑与 API 架构

探索 app.py 应用入口
解析 models/universities.py 中的"智能表选择"算法
讲解 API 路由的实现


第二部分：数据工程与脚本

介绍 ETL 流程（提取、转换、加载）
展示如何在不同数据集间标准化大学名称
阐述动态排名发现机制



🚀 项目介绍
University Ranking Backend 是一个集中式服务，为全球大学提供详细信息。
核心功能：

数据聚合：整合来自多个来源（QS、US News、Niche）的排名数据
多语言支持：内置英文和中文大学名称支持
智能过滤：支持按名称、国家、城市和排名标准进行搜索

目标是创建一个轻量级、易查询的接口，让前端应用能轻松使用，无需关心合并不同排名数据的复杂逻辑。
💡 Vibe Coding 策略
&ldquo;Vibe Coding&rdquo; 是一种 AI 辅助编码方法，开发者与 AI 工具协作加速开发，AI 充当协作伙伴处理重复任务、生成模板代码，并快速探索解决方案。本项目采用 数据驱动、逻辑其次 的策略，并得到 AI 的充分协助。

数据收集与质量检查：

首先在 data/ 目录收集原始数据（CSV、JSON 格式）
通过"质量检查"确保数据统一一致、排名准确、格式规范


脚本化处理流程：

编写独立脚本（scripts/ 目录）处理原始数据和填充 SQLite 数据库
这样做能将混乱的数据清洗与干净的应用逻辑分离


API 作为网关：

数据库就绪后，Flask API 作为简单网关构建
重点是让端点易用直观（/filter、/search），而非过度设计



查看 第一部分 和 第二部分 了解 &ldquo;Vibe Coding&rdquo;（AI 辅助开发）如何影响代码结构的具体例子，比如延迟导入和动态表发现。这些模式都通过 AI 协助优化，避免常见陷阱并提升可扩展性。'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://xiaruize.org/zh/post/"},{"@type":"ListItem","position":2,"name":"使用 Vibe Coding 构建大学排名后端","item":"https://xiaruize.org/zh/post/university-ranking-backend/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"使用 Vibe Coding 构建大学排名后端","name":"使用 Vibe Coding 构建大学排名后端","description":"在这篇文章中，我将分享构建 University Ranking Backend 的过程。这是一个 RESTful API，用于聚合和提供来自 QS 和 US News 等权威机构的大学排名数据。我们将探讨 Vibe Coding 策略、技术架构和驱动系统的核心算法。\n📚 完整系列阅读 这个项目内容丰富，我将其分为深入系列文章：\n第一部分：核心逻辑与 API 架构 探索 app.py 应用入口 解析 models/universities.py 中的\u0026quot;智能表选择\u0026quot;算法 讲解 API 路由的实现 第二部分：数据工程与脚本 介绍 ETL 流程（提取、转换、加载） 展示如何在不同数据集间标准化大学名称 阐述动态排名发现机制 🚀 项目介绍 University Ranking Backend 是一个集中式服务，为全球大学提供详细信息。\n核心功能：\n数据聚合：整合来自多个来源（QS、US News、Niche）的排名数据 多语言支持：内置英文和中文大学名称支持 智能过滤：支持按名称、国家、城市和排名标准进行搜索 目标是创建一个轻量级、易查询的接口，让前端应用能轻松使用，无需关心合并不同排名数据的复杂逻辑。\n💡 Vibe Coding 策略 \u0026ldquo;Vibe Coding\u0026rdquo; 是一种 AI 辅助编码方法，开发者与 AI 工具协作加速开发，AI 充当协作伙伴处理重复任务、生成模板代码，并快速探索解决方案。本项目采用 数据驱动、逻辑其次 的策略，并得到 AI 的充分协助。\n数据收集与质量检查： 首先在 data/ 目录收集原始数据（CSV、JSON 格式） 通过\u0026quot;质量检查\u0026quot;确保数据统一一致、排名准确、格式规范 脚本化处理流程： 编写独立脚本（scripts/ 目录）处理原始数据和填充 SQLite 数据库 这样做能将混乱的数据清洗与干净的应用逻辑分离 API 作为网关： 数据库就绪后，Flask API 作为简单网关构建 重点是让端点易用直观（/filter、/search），而非过度设计 查看 第一部分 和 第二部分 了解 \u0026ldquo;Vibe Coding\u0026rdquo;（AI 辅助开发）如何影响代码结构的具体例子，比如延迟导入和动态表发现。这些模式都通过 AI 协助优化，避免常见陷阱并提升可扩展性。\n","keywords":["Python","Flask","Backend","API","SQLite"],"articleBody":"在这篇文章中，我将分享构建 University Ranking Backend 的过程。这是一个 RESTful API，用于聚合和提供来自 QS 和 US News 等权威机构的大学排名数据。我们将探讨 Vibe Coding 策略、技术架构和驱动系统的核心算法。\n📚 完整系列阅读 这个项目内容丰富，我将其分为深入系列文章：\n第一部分：核心逻辑与 API 架构 探索 app.py 应用入口 解析 models/universities.py 中的\"智能表选择\"算法 讲解 API 路由的实现 第二部分：数据工程与脚本 介绍 ETL 流程（提取、转换、加载） 展示如何在不同数据集间标准化大学名称 阐述动态排名发现机制 🚀 项目介绍 University Ranking Backend 是一个集中式服务，为全球大学提供详细信息。\n核心功能：\n数据聚合：整合来自多个来源（QS、US News、Niche）的排名数据 多语言支持：内置英文和中文大学名称支持 智能过滤：支持按名称、国家、城市和排名标准进行搜索 目标是创建一个轻量级、易查询的接口，让前端应用能轻松使用，无需关心合并不同排名数据的复杂逻辑。\n💡 Vibe Coding 策略 “Vibe Coding” 是一种 AI 辅助编码方法，开发者与 AI 工具协作加速开发，AI 充当协作伙伴处理重复任务、生成模板代码，并快速探索解决方案。本项目采用 数据驱动、逻辑其次 的策略，并得到 AI 的充分协助。\n数据收集与质量检查： 首先在 data/ 目录收集原始数据（CSV、JSON 格式） 通过\"质量检查\"确保数据统一一致、排名准确、格式规范 脚本化处理流程： 编写独立脚本（scripts/ 目录）处理原始数据和填充 SQLite 数据库 这样做能将混乱的数据清洗与干净的应用逻辑分离 API 作为网关： 数据库就绪后，Flask API 作为简单网关构建 重点是让端点易用直观（/filter、/search），而非过度设计 查看 第一部分 和 第二部分 了解 “Vibe Coding”（AI 辅助开发）如何影响代码结构的具体例子，比如延迟导入和动态表发现。这些模式都通过 AI 协助优化，避免常见陷阱并提升可扩展性。\n🛠 技术方案 我们选择了轻量级技术栈，既保证开发速度，又保持部署简洁。\n编程语言：Python 3.8+ - 数据密集型后端的首选 Web 框架：Flask - 极简且灵活，不同于 Django 的强制性结构，让我们能构建完全所需的系统 数据库：SQLite3 - 无服务器、基于文件的数据库，完美适合读多写少的应用 扩展库：flask_cors 处理跨域请求，对公开 API 至关重要 项目结构 项目采用清晰、模块化的组织方式：\napp.py - 应用入口 routes/ - API 控制器（如 universities.py） models/ - 数据层（如 SQL 查询构建） data/ \u0026 scripts/ - 原始数据和处理管道 📂 关键函数简介 为保持后端条理清晰，我们将逻辑分散在不同文件中。以下是使系统运转的关键函数：\n1. 应用入口 (app.py) create_app：这是起点。初始化 Flask 应用，配置安全规则（CORS）使前端能安全通信，加载所有 API 路由。 2. API 路由 (routes/) 这些函数如同\"接待员\"，处理用户的 HTTP 请求。\nfilter_universities_route（映射到 /filter）：主搜索引擎。监听用户输入（搜索词、国家、城市）并将其传递给数据库逻辑。 get_university（映射到 /）：获取单个大学的完整资料。用户点击结果查看详情时调用。 get_countries（在 dropdown.py 中）：辅助函数扫描数据库列出所有国家，填充前端下拉菜单，让用户知道可以按哪些条件过滤。 3. 数据逻辑 (models/) 这是繁重工作发生的地方。\nfilter_universities：“大脑\"所在。动态构建 SQL 查询，根据用户选择将大学数据与对应排名表联接。 🧮 算法：动态 SQL 构建 这个后端的核心不是复杂的机器学习模型，而是聪明的 动态 SQL 查询构建器。\n挑战：用户既想看全球排名，也想看特定国家的排名（如\"中国的全球顶级大学”）。\n解决方案：智能表选择。\n代码动态检查请求国家是否有对应排名表。若有，就无缝切换 JOIN 操作到该表，获得更精准的本地排名。\n关键代码片段 这是来自 models/universities.py 的 filter_universities 函数，处理此逻辑。详细行级讲解见 第一部分。\ndef filter_universities(query=None, sort_credit=None, country=None, city=None): conn = get_db_connection() # 默认排名数据源 if sort_credit is None: sort_credit = \"US_News_best global universities_Rankings\" join_table = sort_credit # 智能逻辑：检查是否存在国家特定的排名表 if country: candidate_country = country.lower().strip() candidate_table = f\"US_News_best global universities in {candidate_country}_Rankings\" # ... (检查该表是否在数据库中存在) ... # 若存在，切换到国家特定表 join_table = candidate_table # 基础查询 sql = \"\"\" SELECT Universities.id, Universities.normalized_name, Universities.name, Universities.country, Universities.city, Universities.photo, R.rank_value, T.chinese_name FROM Universities LEFT JOIN University_names_en_to_zh AS T ON Universities.id = T.id \"\"\" # 动态联接 if join_table: sql += f\"\"\" LEFT JOIN \"{join_table}\" AS R ON Universities.normalized_name = R.normalized_name \"\"\" # ... (搜索词、国家、城市的过滤逻辑) ... sql += \" ORDER BY R.rank_value ASC NULLS LAST LIMIT 200\" cursor = conn.execute(sql, params) return [dict(row) for row in cursor.fetchall()] 🔗 相关链接 GitHub 仓库: xiaruize0911/University_Ranking_Backend ","wordCount":"302","inLanguage":"zh","datePublished":"2025-12-07T00:00:00Z","dateModified":"2025-12-07T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://xiaruize.org/zh/post/university-ranking-backend/"},"publisher":{"@type":"Organization","name":"xiaruize's Blog","logo":{"@type":"ImageObject","url":"https://xiaruize.org/favicon.ico"}}}</script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.css integrity=sha384-zh0CIslj+VczCZtlzBcjt5ppRcsAmDnRem7ESsYwWwg3m/OaJ2l4x7YBZl9Kxxib crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.js integrity=sha384-Rma6DA2IPUwhNxmrB/7S3Tno0YY7sFu9WSYMCuulLhIqYSGZ2gKCJWIqhBWqMQfh crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/auto-render.min.js integrity=sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh crossorigin=anonymous onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"\\[",right:"\\]",display:!0},{left:"$$",right:"$$",display:!0},{left:"\\(",right:"\\)",display:!1},{left:"$",right:"$",display:!1}],throwOnError:!0})})</script></head><body id="
    top"><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://xiaruize.org/zh/ accesskey=h title="xiaruize's Blog (Alt + H)">xiaruize's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://xiaruize.org/ title=English aria-label=English>En</a></li></ul></div></div><ul id=menu><li><a href=https://xiaruize.org/zh/categories/ title=categories><span>categories</span></a></li><li><a href=https://xiaruize.org/zh/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">使用 Vibe Coding 构建大学排名后端</h1><div class=post-meta><span title='2025-12-07 00:00:00 +0000 UTC'>2025年12月7日</span>&nbsp;|&nbsp;语言:<ul class=i18n_list><li><a href=https://xiaruize.org/post/university-ranking-backend/>En</a></li></ul></div></header><div class=post-content><p>在这篇文章中，我将分享构建 <strong>University Ranking Backend</strong> 的过程。这是一个 RESTful API，用于聚合和提供来自 QS 和 US News 等权威机构的大学排名数据。我们将探讨 Vibe Coding 策略、技术架构和驱动系统的核心算法。</p><h2 id=-完整系列阅读>📚 完整系列阅读<a hidden class=anchor aria-hidden=true href=#-完整系列阅读>#</a></h2><p>这个项目内容丰富，我将其分为深入系列文章：</p><ul><li><strong><a href=https://xiaruize.org/zh/post/university-ranking-backend-part-1/>第一部分：核心逻辑与 API 架构</a></strong><ul><li>探索 <code>app.py</code> 应用入口</li><li>解析 <code>models/universities.py</code> 中的"智能表选择"算法</li><li>讲解 API 路由的实现</li></ul></li><li><strong><a href=https://xiaruize.org/zh/post/university-ranking-backend-part-2/>第二部分：数据工程与脚本</a></strong><ul><li>介绍 ETL 流程（提取、转换、加载）</li><li>展示如何在不同数据集间标准化大学名称</li><li>阐述动态排名发现机制</li></ul></li></ul><h2 id=-项目介绍>🚀 项目介绍<a hidden class=anchor aria-hidden=true href=#-项目介绍>#</a></h2><p><strong>University Ranking Backend</strong> 是一个集中式服务，为全球大学提供详细信息。</p><p><strong>核心功能：</strong></p><ul><li><strong>数据聚合</strong>：整合来自多个来源（QS、US News、Niche）的排名数据</li><li><strong>多语言支持</strong>：内置英文和中文大学名称支持</li><li><strong>智能过滤</strong>：支持按名称、国家、城市和排名标准进行搜索</li></ul><p>目标是创建一个轻量级、易查询的接口，让前端应用能轻松使用，无需关心合并不同排名数据的复杂逻辑。</p><h2 id=-vibe-coding-策略>💡 Vibe Coding 策略<a hidden class=anchor aria-hidden=true href=#-vibe-coding-策略>#</a></h2><p>&ldquo;Vibe Coding&rdquo; 是一种 AI 辅助编码方法，开发者与 AI 工具协作加速开发，AI 充当协作伙伴处理重复任务、生成模板代码，并快速探索解决方案。本项目采用 <strong>数据驱动、逻辑其次</strong> 的策略，并得到 AI 的充分协助。</p><ol><li><strong>数据收集与质量检查</strong>：<ul><li>首先在 <code>data/</code> 目录收集原始数据（CSV、JSON 格式）</li><li>通过"质量检查"确保数据统一一致、排名准确、格式规范</li></ul></li><li><strong>脚本化处理流程</strong>：<ul><li>编写独立脚本（<code>scripts/</code> 目录）处理原始数据和填充 SQLite 数据库</li><li>这样做能将混乱的数据清洗与干净的应用逻辑分离</li></ul></li><li><strong>API 作为网关</strong>：<ul><li>数据库就绪后，Flask API 作为简单网关构建</li><li>重点是让端点易用直观（<code>/filter</code>、<code>/search</code>），而非过度设计</li></ul></li></ol><p>查看 <a href=https://xiaruize.org/zh/post/university-ranking-backend-part-1/>第一部分</a> 和 <a href=https://xiaruize.org/zh/post/university-ranking-backend-part-2/>第二部分</a> 了解 &ldquo;Vibe Coding&rdquo;（AI 辅助开发）如何影响代码结构的具体例子，比如延迟导入和动态表发现。这些模式都通过 AI 协助优化，避免常见陷阱并提升可扩展性。</p><h2 id=-技术方案>🛠 技术方案<a hidden class=anchor aria-hidden=true href=#-技术方案>#</a></h2><p>我们选择了轻量级技术栈，既保证开发速度，又保持部署简洁。</p><ul><li><strong>编程语言</strong>：<strong>Python 3.8+</strong> - 数据密集型后端的首选</li><li><strong>Web 框架</strong>：<strong>Flask</strong> - 极简且灵活，不同于 Django 的强制性结构，让我们能构建完全所需的系统</li><li><strong>数据库</strong>：<strong>SQLite3</strong> - 无服务器、基于文件的数据库，完美适合读多写少的应用</li><li><strong>扩展库</strong>：<code>flask_cors</code> 处理跨域请求，对公开 API 至关重要</li></ul><h3 id=项目结构>项目结构<a hidden class=anchor aria-hidden=true href=#项目结构>#</a></h3><p>项目采用清晰、模块化的组织方式：</p><ul><li><code>app.py</code> - 应用入口</li><li><code>routes/</code> - API 控制器（如 <code>universities.py</code>）</li><li><code>models/</code> - 数据层（如 SQL 查询构建）</li><li><code>data/</code> & <code>scripts/</code> - 原始数据和处理管道</li></ul><h2 id=-关键函数简介>📂 关键函数简介<a hidden class=anchor aria-hidden=true href=#-关键函数简介>#</a></h2><p>为保持后端条理清晰，我们将逻辑分散在不同文件中。以下是使系统运转的关键函数：</p><h3 id=1-应用入口-apppy>1. 应用入口 (<code>app.py</code>)<a hidden class=anchor aria-hidden=true href=#1-应用入口-apppy>#</a></h3><ul><li><strong><code>create_app</code></strong>：这是起点。初始化 Flask 应用，配置安全规则（CORS）使前端能安全通信，加载所有 API 路由。</li></ul><h3 id=2-api-路由-routes>2. API 路由 (<code>routes/</code>)<a hidden class=anchor aria-hidden=true href=#2-api-路由-routes>#</a></h3><p>这些函数如同"接待员"，处理用户的 HTTP 请求。</p><ul><li><strong><code>filter_universities_route</code></strong>（映射到 <code>/filter</code>）：主搜索引擎。监听用户输入（搜索词、国家、城市）并将其传递给数据库逻辑。</li><li><strong><code>get_university</code></strong>（映射到 <code>/&lt;id></code>）：获取单个大学的完整资料。用户点击结果查看详情时调用。</li><li><strong><code>get_countries</code></strong>（在 <code>dropdown.py</code> 中）：辅助函数扫描数据库列出所有国家，填充前端下拉菜单，让用户知道可以按哪些条件过滤。</li></ul><h3 id=3-数据逻辑-models>3. 数据逻辑 (<code>models/</code>)<a hidden class=anchor aria-hidden=true href=#3-数据逻辑-models>#</a></h3><p>这是繁重工作发生的地方。</p><ul><li><strong><code>filter_universities</code></strong>：&ldquo;大脑"所在。动态构建 SQL 查询，根据用户选择将大学数据与对应排名表联接。</li></ul><h2 id=-算法动态-sql-构建>🧮 算法：动态 SQL 构建<a hidden class=anchor aria-hidden=true href=#-算法动态-sql-构建>#</a></h2><p>这个后端的核心不是复杂的机器学习模型，而是聪明的 <strong>动态 SQL 查询构建器</strong>。</p><p><strong>挑战</strong>：用户既想看全球排名，也想看特定国家的排名（如"中国的全球顶级大学&rdquo;）。</p><p><strong>解决方案</strong>：<strong>智能表选择</strong>。</p><p>代码动态检查请求国家是否有对应排名表。若有，就无缝切换 <code>JOIN</code> 操作到该表，获得更精准的本地排名。</p><h3 id=关键代码片段>关键代码片段<a hidden class=anchor aria-hidden=true href=#关键代码片段>#</a></h3><p>这是来自 <code>models/universities.py</code> 的 <code>filter_universities</code> 函数，处理此逻辑。详细行级讲解见 <a href=https://xiaruize.org/zh/post/university-ranking-backend-part-1/>第一部分</a>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>filter_universities</span><span class=p>(</span><span class=n>query</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=n>sort_credit</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=n>country</span><span class=o>=</span><span class=kc>None</span><span class=p>,</span> <span class=n>city</span><span class=o>=</span><span class=kc>None</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>conn</span> <span class=o>=</span> <span class=n>get_db_connection</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=c1># 默认排名数据源</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>sort_credit</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>sort_credit</span> <span class=o>=</span> <span class=s2>&#34;US_News_best global universities_Rankings&#34;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>join_table</span> <span class=o>=</span> <span class=n>sort_credit</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 智能逻辑：检查是否存在国家特定的排名表</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>country</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>candidate_country</span> <span class=o>=</span> <span class=n>country</span><span class=o>.</span><span class=n>lower</span><span class=p>()</span><span class=o>.</span><span class=n>strip</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=n>candidate_table</span> <span class=o>=</span> <span class=sa>f</span><span class=s2>&#34;US_News_best global universities in </span><span class=si>{</span><span class=n>candidate_country</span><span class=si>}</span><span class=s2>_Rankings&#34;</span>
</span></span><span class=line><span class=cl>        <span class=c1># ... (检查该表是否在数据库中存在) ...</span>
</span></span><span class=line><span class=cl>        <span class=c1># 若存在，切换到国家特定表</span>
</span></span><span class=line><span class=cl>        <span class=n>join_table</span> <span class=o>=</span> <span class=n>candidate_table</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 基础查询</span>
</span></span><span class=line><span class=cl>    <span class=n>sql</span> <span class=o>=</span> <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>        SELECT Universities.id, Universities.normalized_name, Universities.name,
</span></span></span><span class=line><span class=cl><span class=s2>               Universities.country, Universities.city, Universities.photo,
</span></span></span><span class=line><span class=cl><span class=s2>               R.rank_value, T.chinese_name
</span></span></span><span class=line><span class=cl><span class=s2>        FROM Universities
</span></span></span><span class=line><span class=cl><span class=s2>        LEFT JOIN University_names_en_to_zh AS T ON Universities.id = T.id
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 动态联接</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>join_table</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>sql</span> <span class=o>+=</span> <span class=sa>f</span><span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>            LEFT JOIN &#34;</span><span class=si>{</span><span class=n>join_table</span><span class=si>}</span><span class=s2>&#34; AS R
</span></span></span><span class=line><span class=cl><span class=s2>            ON Universities.normalized_name = R.normalized_name
</span></span></span><span class=line><span class=cl><span class=s2>        &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># ... (搜索词、国家、城市的过滤逻辑) ...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>sql</span> <span class=o>+=</span> <span class=s2>&#34; ORDER BY R.rank_value ASC NULLS LAST LIMIT 200&#34;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>cursor</span> <span class=o>=</span> <span class=n>conn</span><span class=o>.</span><span class=n>execute</span><span class=p>(</span><span class=n>sql</span><span class=p>,</span> <span class=n>params</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>[</span><span class=nb>dict</span><span class=p>(</span><span class=n>row</span><span class=p>)</span> <span class=k>for</span> <span class=n>row</span> <span class=ow>in</span> <span class=n>cursor</span><span class=o>.</span><span class=n>fetchall</span><span class=p>()]</span>
</span></span></code></pre></div><h2 id=-相关链接>🔗 相关链接<a hidden class=anchor aria-hidden=true href=#-相关链接>#</a></h2><ul><li><strong>GitHub 仓库</strong>: <a href=https://github.com/xiaruize0911/University_Ranking_Backend>xiaruize0911/University_Ranking_Backend</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://xiaruize.org/zh/tags/python/>Python</a></li><li><a href=https://xiaruize.org/zh/tags/flask/>Flask</a></li><li><a href=https://xiaruize.org/zh/tags/backend/>Backend</a></li><li><a href=https://xiaruize.org/zh/tags/api/>API</a></li><li><a href=https://xiaruize.org/zh/tags/sqlite/>SQLite</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://xiaruize.org/zh/>xiaruize's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>